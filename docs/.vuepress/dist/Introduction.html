<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>How it works | Proxima</title>
    <meta name="description" content="An authenticated database">
    
    
    <link rel="preload" href="/assets/css/0.styles.bb534371.css" as="style"><link rel="preload" href="/assets/js/app.9fd9176d.js" as="script"><link rel="preload" href="/assets/js/2.0bdd1918.js" as="script"><link rel="preload" href="/assets/js/6.63107904.js" as="script"><link rel="prefetch" href="/assets/js/10.b101d8e6.js"><link rel="prefetch" href="/assets/js/11.ffd65c51.js"><link rel="prefetch" href="/assets/js/12.fd2abbf6.js"><link rel="prefetch" href="/assets/js/13.25eea30e.js"><link rel="prefetch" href="/assets/js/14.50e7808d.js"><link rel="prefetch" href="/assets/js/15.428485f1.js"><link rel="prefetch" href="/assets/js/16.d57263cb.js"><link rel="prefetch" href="/assets/js/17.75288a8f.js"><link rel="prefetch" href="/assets/js/18.a6140f04.js"><link rel="prefetch" href="/assets/js/19.3c96e341.js"><link rel="prefetch" href="/assets/js/20.64975db8.js"><link rel="prefetch" href="/assets/js/3.e5b4d07e.js"><link rel="prefetch" href="/assets/js/4.bd682c50.js"><link rel="prefetch" href="/assets/js/5.7814d92d.js"><link rel="prefetch" href="/assets/js/7.5cbb688e.js"><link rel="prefetch" href="/assets/js/8.4681f9e3.js"><link rel="prefetch" href="/assets/js/9.b67cd1ec.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bb534371.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Proxima</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/" class="sidebar-link">Proxima</a></li><li><a href="/Introduction.html" class="active sidebar-link">How it works</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Introduction.html#what-do-we-do" class="sidebar-link">What do we do?</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#our-goal" class="sidebar-link">Our goal</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#our-product" class="sidebar-link">Our Product</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#benefits" class="sidebar-link">Benefits</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#stakeholders" class="sidebar-link">Stakeholders</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#how-do-we-do-it" class="sidebar-link">How do we do it?</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#queries" class="sidebar-link">Queries</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#authenticated-datastore" class="sidebar-link">Authenticated Datastore</a></li><li class="sidebar-sub-header"><a href="/Introduction.html#audits-4" class="sidebar-link">Audits</a></li></ul></li><li><a href="/Getting-Started.html" class="sidebar-link">Getting Started</a></li><li><a href="/CLI.html" class="sidebar-link">Proxima CLI</a></li><li><a href="/Proxima-SDK.html" class="sidebar-link">Proxima SDK JS</a></li><li><a href="/Proxima-Node.html" class="sidebar-link">Proxima Node</a></li><li><a href="/Data-Vertex.html" class="sidebar-link">Data Vertex</a></li><li><a href="/Data-Aggregator.html" class="sidebar-link">Data Aggregator</a></li><li><a href="/Blockchain-Client.html" class="sidebar-link">Blockchain-Client</a></li><li><a href="/ProximaDB.html" class="sidebar-link">ProximaDB</a></li><li><a href="/Research.html" class="sidebar-link">Research</a></li><li><a href="/FAQ.html" class="sidebar-link">Considerations and Questions</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="how-it-works"><a href="#how-it-works" aria-hidden="true" class="header-anchor">#</a> How it works</h1> <h2 id="what-do-we-do"><a href="#what-do-we-do" aria-hidden="true" class="header-anchor">#</a> What do we do?</h2> <p><strong>Blockchain data is tough to truly authenticate.</strong></p> <p>How do you know that you are getting accurate and sound data from the correct blockchain? You have no idea if the data coming from your account balance, query, or Decentralized application events are accurate and timely. The result can lead to major issues with visibility, analytics, and finances within your business. It can mean the difference between success or failure.</p> <h3 id="examples"><a href="#examples" aria-hidden="true" class="header-anchor">#</a> Examples</h3> <ul><li><em>Did my user pay? What are the interest rates?</em></li> <li><em>How many users are there? What do my orders look like?</em></li> <li><em>What is my account balance? What transactions have I been a part of?</em></li></ul> <p>When dealing with data security it is not enough to “trust”. Proxima provides the convenience, feature set, and speed of centralized providers <strong>AND</strong> maintains the audibility and security of the blockchain.</p> <h2 id="our-goal"><a href="#our-goal" aria-hidden="true" class="header-anchor">#</a> Our goal</h2> <p>Decentralize the ability to <strong>provide data, interact with data</strong> to <strong>empower DApp developers</strong>, provide tools that <strong>speed up the creation of DApps</strong>, and <strong>drive adoption of blockchain technology</strong>. Our solution is general enough to <strong>enable our decentralized data providers</strong> to provide data for DApps <strong>for several blockchains / smart contract platforms</strong>, while basing our <strong>security on the consensus of the blockchain that the data is coming from</strong>.</p> <h2 id="our-product"><a href="#our-product" aria-hidden="true" class="header-anchor">#</a> Our Product</h2> <p>We provide default event mappings for every developer so there is no setup needed aside from listing the contract ABI code, the data source, and the address. Moreover, our methodology does not employ any consensus method for queries or writes because it ties the data in each with the blockchain itself.</p> <h2 id="benefits"><a href="#benefits" aria-hidden="true" class="header-anchor">#</a> Benefits</h2> <ul><li><p><strong>Security</strong>
Instead of relying on the consensus or trust of another data provider, the security of the data on Proxima is gauranteed by the blockchain that the developer uses. This is done by creating a trail between every piece of data in Proxima, and the block that it originates from.</p></li> <li><p><strong>Lower latency</strong>
Queries for data in Proxima need to have only one hop, this creates an experience that is similar to the traditional request-response method. Other such methods have consensus mechanisms for queries, which can lead to quadratic bounds with regard to the number of messages being passed.</p></li> <li><p><strong>Lower cost</strong>
Traditional approaches for data delivery, require large clusters of nodes to run consensus on individual queries. This is ineffective, and lowers the security. Through Proxima, each query does not need trust because it can be audited. This lowers the cost to serve a query to match traditional standards. Furthermore, it does not need trust so it opens up the ability to serve data which can further drop the price.</p></li></ul> <h3 id="features"><a href="#features" aria-hidden="true" class="header-anchor">#</a> Features</h3> <ul><li><em>Events, State</em></li> <li><em>Filtering (soundness, not completeness), Range</em> (soundness, not completeness)*</li> <li><em>Blockchain agnostic</em></li> <li><em>Trustless data</em></li> <li><em>Performant queries</em></li></ul> <h2 id="stakeholders"><a href="#stakeholders" aria-hidden="true" class="header-anchor">#</a> Stakeholders</h2> <p><em>There exist three major stakeholders in the Proxima ecosystem.</em></p> <ul><li><p><strong>Blockchains</strong>
Blockchains suffer from two major issues adoption and data delivery. In order to be sustainable blockchains need to have a way to easily get data from the chain, and they need a highly secure, cost effective method to maintain this infrastructure indefinitely. Through Proxima, these blockchains do not need to compromise on any of these aspects.</p></li> <li><p><strong>Decentralized Applications</strong>
Decentralized applications can use Proxima, as a method for maintaining an easy connection to the data that preserves security. Instead of building their own custom caching and data solutions, these applications can build on top of a highly secure, blazing fast data provider.</p></li> <li><p><strong>Users</strong>
Users receive faster performance and a more diverse experience. This can be seen with faster page load times, and a real-time experience.</p></li></ul> <h3 id="example-use-case"><a href="#example-use-case" aria-hidden="true" class="header-anchor">#</a> Example Use Case</h3> <h4 id="goal"><a href="#goal" aria-hidden="true" class="header-anchor">#</a> Goal</h4> <p>A developer wants to query the blockchain, to get data from a specific DApp, a decentralized exchange. This DApp utilizes multiple smart contracts to maintain orderbooks and reserves in a decentralized manner. The goal is to get a cohesive view of the orderbooks, reserves, and exchange in a fast, secure manner.</p> <h4 id="problem"><a href="#problem" aria-hidden="true" class="header-anchor">#</a> Problem</h4> <p>The current method of blockchain querying would be to have the developer write a custom-solution that queries each individual contract, formats the data, and delivers it to the user. Along with being difficult to create for the developer, this type of system experiences high latency with requests taking minutes.</p> <h4 id="solution"><a href="#solution" aria-hidden="true" class="header-anchor">#</a> Solution</h4> <p>The developer can make a Proxima data node that incorporates subgraphs for each of the reserves and orderbooks for their exchange. These subgraphs can be autogenerated to collect events, state, and ensure that this state is truly tied to the blockchain through an authenticated data structure. This enables the developer to have faster queries by several orders of magnitude, while maintaining the security of the blockchain they are querying from.</p> <h4 id="outcomes"><a href="#outcomes" aria-hidden="true" class="header-anchor">#</a> Outcomes</h4> <ul><li>Faster queries</li> <li>Lower storage footprint</li> <li>Trustless queries</li> <li>Greater Scalability</li> <li>Easier interface</li> <li>Lower costs</li></ul> <h2 id="how-do-we-do-it"><a href="#how-do-we-do-it" aria-hidden="true" class="header-anchor">#</a> How do we do it?</h2> <p>Proxima provides default mapping of events and stores them within an authenticated data store, giving developers the ability to query this through a graphQL interface. Queries are done through a specialized node that uses an authenticated data store to provide a Merkle-proof for the query. To ensure the security of the data, Proxima leaves an auditable trail for DApp developers to trace the path of their data to its source. We cannot change the authenticated data structure, so security does not have to be re-tried by each new user.</p> <p><img src="/assets/img/overall-architecture_1.fc3faa18.png" alt=""></p> <h3 id="index-nodes"><a href="#index-nodes" aria-hidden="true" class="header-anchor">#</a> Index Nodes</h3> <p>The index node is responsible for connecting the queries to the correct &quot;subgraph&quot;. They will maintain a smart contract index of subgraphs, and eventually be responsible for dealing with payments and subscriptions. The index of subgraphs will be represented as a smart contract on Ethereum through the testnet phase. Eventually the index will be migrated to a higher throughput chain, like the tendermint sidechain on Cosmos.</p> <p><em>Note: the index nodes do not actually store any &quot;subgraphs&quot;, they simply connect to subgraphs stored by the query nodes.</em></p> <h3 id="query-nodes"><a href="#query-nodes" aria-hidden="true" class="header-anchor">#</a> Query Nodes</h3> <p>Query nodes are responsible for storing and providing data for subgraphs. Query nodes can be deployed to our hosting DNS service through a manifest that defines data sources, contracts, and any extra mappings. This manifest is deployed to the IPNS, to enable deployment to the mesh as well as deployment to our own hosting solution.</p> <h3 id="subgraphs"><a href="#subgraphs" aria-hidden="true" class="header-anchor">#</a> Subgraphs</h3> <p>Subgraphs represent a contained data set that can be queried, auditted, and reused within the Proxima network. The easiest analogy for subgraphs, is that they represent tables of data complete with schema, transformations, and queries.</p> <div class="language- extra-class"><pre class="language-text"><code>subgraph
  entities:
    - ...
  schema:
    - ...
  mappings:
    - ...
  datasources:
    -  ...
</code></pre></div><h3 id="entities"><a href="#entities" aria-hidden="true" class="header-anchor">#</a> Entities</h3> <p>Entities are formulations of objects in Proxima. They can represent Users, Accounts, Items, Orders, etc. The entity will define the values, the &quot;audits&quot; associated with the values, and how to index/write the objects to the authenticated database.</p> <h4 id="schema"><a href="#schema" aria-hidden="true" class="header-anchor">#</a> Schema</h4> <p>The schema exists as a part of the entity, it will enable queries, and show the data that is held within the entity. This
schema will eventually be able to contain other entities.</p> <h4 id="verification"><a href="#verification" aria-hidden="true" class="header-anchor">#</a> Verification</h4> <p>Each entity has a function(s) that will verify the validity of the data they hold. An example of this would be a block<br>
entity have a verification function that ensures the blockhead hashes to the blockhash.</p> <h4 id="audits"><a href="#audits" aria-hidden="true" class="header-anchor">#</a> Audits</h4> <p>An entity will have data from other sources, it is necessary to be able to audit this data. Entities have specific<br>
subroutines that take run queries on subgraphs. These queries are known as &quot;audits&quot;, and they will ensure the validity of
the data given. An example of such an audit would be a query for a Transaction that checks if the block, associated with the
blockHash, exists.</p> <h4 id="example-transaction"><a href="#example-transaction" aria-hidden="true" class="header-anchor">#</a> Example: Transaction</h4> <p>An example entity to use is a transaction, (a UTXO in this case). Look at how the schema defines the data, the</p> <h4 id="schema-2"><a href="#schema-2" aria-hidden="true" class="header-anchor">#</a> Schema</h4> <pre><code>```
Transaction {
    transactionHash: Uint256
    from: Address
    to: Address
    value: Uint256
    signature: bytes
    blockHash: Uint256
}
```
</code></pre> <h4 id="verification-2"><a href="#verification-2" aria-hidden="true" class="header-anchor">#</a> Verification</h4> <p>The verification in this case would be to ensure that the signed Transaction was hashed to the correct Hash. Put simply it would look like:</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">verification</span><span class="token punctuation">(</span><span class="token parameter">Transaction<span class="token punctuation">,</span> transactionHash</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">keccak256</span><span class="token punctuation">(</span>Transaction<span class="token punctuation">)</span> <span class="token operator">==</span> transactionHash<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="audits-2"><a href="#audits-2" aria-hidden="true" class="header-anchor">#</a> Audits</h4> <p>The auditting process would include a query and a validation function. For the transaction it would query the blockHash,
then it would perform the validation function that checks that the transaction is in Transaction Trie of the selected
Block.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">AuditTransaction</span><span class="token punctuation">(</span><span class="token parameter">Transaction</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Block <span class="token operator">=</span> <span class="token function">Query</span><span class="token punctuation">(</span>Transaction<span class="token punctuation">)</span>
  <span class="token keyword">return</span> Block <span class="token constant">AND</span> <span class="token function">Validate</span><span class="token punctuation">(</span>Transaction<span class="token punctuation">,</span> Block<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="query"><a href="#query" aria-hidden="true" class="header-anchor">#</a> Query</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Query</span><span class="token punctuation">(</span><span class="token parameter">Transaction</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   Block<span class="token punctuation">,</span> Proof <span class="token operator">=</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'subgraph blocks'</span><span class="token punctuation">,</span> Transaction<span class="token punctuation">.</span>BlockHash<span class="token punctuation">)</span>
   <span class="token keyword">if</span> Proof<span class="token punctuation">.</span>verify<span class="token punctuation">:</span>
     <span class="token keyword">return</span> Block
   <span class="token keyword">return</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="validation"><a href="#validation" aria-hidden="true" class="header-anchor">#</a> Validation</h5> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Validate</span><span class="token punctuation">(</span><span class="token parameter">Transaction<span class="token punctuation">,</span> Block</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Transaction<span class="token punctuation">.</span>Hash <span class="token keyword">in</span> Block<span class="token punctuation">.</span>TransactionTrie<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="datasources"><a href="#datasources" aria-hidden="true" class="header-anchor">#</a> Datasources</h3> <p>Subgraphs can be used by other subgraphs (e.g. Ethereum subgraph being used by DApps), these are defined as datasources.</p> <h4 id="subgraphs-2"><a href="#subgraphs-2" aria-hidden="true" class="header-anchor">#</a> Subgraphs</h4> <p>Subgraphs can be used as a datasource for other subgraphs. These subgraphs are referenced and used through the Proxima Index Node. This method makes it easy to define and use subgraphs.</p> <div class="language- extra-class"><pre class="language-text"><code>  datasource:
      type: Subgraph
       id: Ethereum-Subgraph
      name: Ethereum
</code></pre></div><h4 id="external-data-sources"><a href="#external-data-sources" aria-hidden="true" class="header-anchor">#</a> External data sources</h4> <p>External datasources are more difficult to build, and must contain pre-built entities. By doing this it is possible to use the external datasource in the same manner that a subgraph can be used.</p> <div class="language- extra-class"><pre class="language-text"><code>  datasource:
      type: External
      name: Ethereum
      ingestor: ...
      entities: ...
      mapping:
      - handlers
      - abi/schema
</code></pre></div><h2 id="queries"><a href="#queries" aria-hidden="true" class="header-anchor">#</a> Queries</h2> <p>Queries in Proxima, are given responses that are broken into entities. Each entity represents an individual data record that is being requested in the query itself. Since they are designed to be verifiable, they have components for proofs audits.</p> <p><img src="/assets/img/query.8d1b904f.png" alt=""></p> <p>Each <em>entity</em> within a query is composed of the following attributes:</p> <h4 id="data"><a href="#data" aria-hidden="true" class="header-anchor">#</a> Data</h4> <p>The data contained within each identity is associated with the schema of the entity itself. This is what the query is looking at.</p> <h4 id="proof"><a href="#proof" aria-hidden="true" class="header-anchor">#</a> Proof</h4> <p>This is the <em>proof-of-membership</em> within the Proxima Database. The Proof itself relies on the Merkle root of the database, and is authenticated with the hash of the value.</p> <h4 id="audits-3"><a href="#audits-3" aria-hidden="true" class="header-anchor">#</a> Audits</h4> <p>The audit provides a <em>Proof-of-Correctness</em> for the entity that is being queried, and is sourced by the entity itself. This involves conducting a separate query query of data that is directly tied to the entity. For example, a transaction &quot;audit&quot; would return the block whose blockhash is referenced by the transaction, and a proof-of-membership for this block.</p> <h2 id="authenticated-datastore"><a href="#authenticated-datastore" aria-hidden="true" class="header-anchor">#</a> Authenticated Datastore</h2> <p>Proxima uses ProximaDB, a bolt-on component of the powerful Urkel NoSQL database, that implements a Flat-File Merkle Trie (FFMT). We utilize the Flat-File Merkle Trie, like see in Urkel, because of the query speed (&gt;1 ms), the reduced size of the proofs (&gt;1kb), as well as the low storage footprint. FFMTs are especially useful in this implementation because they map from the internal nodes of the trie directly to the location of the data that they are referencing. For more information on this check out the <a href="https://handshake.org/files/handshake.txt" target="_blank" rel="noopener noreferrer">Handshake paper<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <p>Along with adding features like range queries and load-balancing, Ruffle provides the default authentication and performance seen in the Urkel database. Our data store provides Merkle proofs for data to ensure the authenticity and immutability of all data within it.</p> <h2 id="audits-4"><a href="#audits-4" aria-hidden="true" class="header-anchor">#</a> Audits</h2> <p>The blocks of a blockchain are immutable, but blocks are only linked to their immediate neighbors, so the history of the blockchain can only be verified by downloading the entire chain. This means that it is only possible to audit data (e.g. transactions, state, and blocks) from a blockchain, by running a full node and synchronizing with every block in the blockchain’s history.</p> <p>Our system maintains the same auditing structure of blockchains, but it stores blocks within an authenticated database, so it is possible to verify membership of blocks without downloading the entire history. This enables fast and efficient audits.</p> <h3 id="example-audits"><a href="#example-audits" aria-hidden="true" class="header-anchor">#</a> Example Audits</h3> <ul><li><em>Is this block a part of the Ethereum block?</em></li> <li><em>Is this transaction really embedded in this block?</em></li> <li><em>Is this state located in the state trie for the current block?</em></li></ul> <p>Audits like these can be called within a query to guarantee that the information provided is correct. Audits can also be chained together in a recursive manner, this is known as an audit trail. As our product progresses, audits can be updated and added to improve the security and rigor of the audit itself.</p> <p>Audits and audit trails would take a lot of time if they are used for every query. Since the database is authenticated, probabilistic audits can be used by developers in instances where there is a high amount of overlap between queries. This lowers the number of audits needed to be completed for highly used sets while maintaining developer security guarantees.</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">6/23/2019, 7:49:30 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/" class="prev router-link-active">
        Proxima
      </a></span> <span class="next"><a href="/Getting-Started.html">
        Getting Started
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9fd9176d.js" defer></script><script src="/assets/js/2.0bdd1918.js" defer></script><script src="/assets/js/6.63107904.js" defer></script>
  </body>
</html>
