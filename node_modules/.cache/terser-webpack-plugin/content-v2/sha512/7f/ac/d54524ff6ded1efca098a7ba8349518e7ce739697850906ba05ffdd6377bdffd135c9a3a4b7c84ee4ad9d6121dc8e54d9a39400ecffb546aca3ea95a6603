{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{184:function(e,t,a){e.exports=a.p+\"assets/img/overall-architecture_1.fc3faa18.png\"},185:function(e,t,a){e.exports=a.p+\"assets/img/query.8d1b904f.png\"},190:function(e,t,a){\"use strict\";a.r(t);var s=a(0),r=Object(s.a)({},function(){var e=this,t=e.$createElement,s=e._self._c||t;return s(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[s(\"h1\",{attrs:{id:\"proxima\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#proxima\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Proxima\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"what-do-we-do\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#what-do-we-do\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" What do we do?\")]),e._v(\" \"),s(\"p\",[e._v(\"Blockchain data is tough to truly authenticate.\\nHow do you know that you are getting accurate and sound data from the correct blockchain? You have no idea if the data coming from your account balance, query, or Decentralized application events are accurate and timely. The result can lead to major issues with visibility, analytics, and finances within your business. It can mean the difference between success or failure.\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"examples\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#examples\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Examples\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"em\",[e._v(\"Did my user pay? What are the interest rates?\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"How many users are there? What do my orders look like?\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"What is my account balance? What transactions have I been a part of?\")])])]),e._v(\" \"),s(\"p\",[e._v(\"When dealing with data security it is not enough to “trust”. Proxima provides the convenience, feature set, and speed of centralized providers \"),s(\"strong\",[e._v(\"AND\")]),e._v(\" maintains the audibility and trustlessness of the blockchain.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"our-goal\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#our-goal\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Our goal\")]),e._v(\" \"),s(\"p\",[e._v(\"Decentralize the ability to \"),s(\"strong\",[e._v(\"provide data, interact with data\")]),e._v(\" to \"),s(\"strong\",[e._v(\"empower DApp developers\")]),e._v(\", provide tools that \"),s(\"strong\",[e._v(\"speed up the creation of DApps\")]),e._v(\", and \"),s(\"strong\",[e._v(\"drive adoption of blockchain technology\")]),e._v(\". Our solution is general enough to \"),s(\"strong\",[e._v(\"enable our decentralized data providers\")]),e._v(\" to provide data for DApps \"),s(\"strong\",[e._v(\"for several blockchains / smart contract platforms\")]),e._v(\", while basing our \"),s(\"strong\",[e._v(\"security on the consensus of the blockchain that the data is coming from\")]),e._v(\".\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"our-product\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#our-product\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Our Product\")]),e._v(\" \"),s(\"p\",[e._v(\"We provide default event mappings for every developer so there is no setup needed aside from listing the contract ABI code, the data source, and the address. Moreover, our methodology does not employ any consensus method for queries or writes because it ties the data in each with the blockchain itself.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"benefits\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#benefits\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Benefits\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[s(\"strong\",[e._v(\"Security\")]),e._v(\"\\nInstead of relying on the consensus or trust of another data provider, the security of the data on Proxima is gauranteed by the blockchain that the developer uses. This is done by creating a trail between every piece of data in Proxima, and the block that it originates from.\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[s(\"strong\",[e._v(\"Lower latency\")]),e._v(\"\\nQueries for data in Proxima need to have only one hop, this creates an experience that is similar to the traditional request-response method. Other such methods have consensus mechanisms for queries, which can lead to quadratic bounds with regard to the number of messages being passed.\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[s(\"strong\",[e._v(\"Lower cost\")]),e._v(\"\\nTraditional approaches for data delivery, require large clusters of nodes to run consensus on individual queries. This is ineffective, and lowers the security. Through Proxima, each query does not need trust because it can be audited. This lowers the cost to serve a query to match traditional standards. Furthermore, it does not need trust so it opens up the ability to serve data which can further drop the price.\")])])]),e._v(\" \"),s(\"h2\",{attrs:{id:\"stakeholders\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#stakeholders\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Stakeholders\")]),e._v(\" \"),s(\"p\",[s(\"em\",[e._v(\"There exist three major stakeholders in the Proxima ecosystem.\")])]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"p\",[s(\"strong\",[e._v(\"Blockchains\")]),e._v(\"\\nBlockchains suffer from two major issues adoption and data delivery. In order to be sustainable blockchains need to have a way to easily get data from the chain, and they need a highly secure, cost effective method to maintain this infrastructure indefinitely. Through Proxima, these blockchains do not need to compromise on any of these aspects.\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[s(\"strong\",[e._v(\"Decentralized Applications\")]),e._v(\"\\nDecentralized applications can use Proxima, as a method for maintaining an easy connection to the data that preserves security. Instead of building their own custom caching and data solutions, these applications can build ontop of a highly secure, blazing fast data provider.\")])]),e._v(\" \"),s(\"li\",[s(\"p\",[s(\"strong\",[e._v(\"Users\")]),e._v(\"\\nUsers receive faster performance and a more diverse experience. This can be seen with faster page load times, and a real-time experience.\")])])]),e._v(\" \"),s(\"h3\",{attrs:{id:\"features\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#features\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Features\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"em\",[e._v(\"Events, State\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"Filtering (soundness, not completeness), Range\")]),e._v(\" (soundness, not completeness)*\")]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"Blockchain agnostic\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"Trustless data\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"Performant queries\")])])]),e._v(\" \"),s(\"h3\",{attrs:{id:\"example-use-case\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#example-use-case\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Example Use Case\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"goal\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#goal\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Goal\")]),e._v(\" \"),s(\"p\",[e._v(\"A developer wants to query the blockchain, to get data from a specific DApp, a decentralized exchange. This DApp utilizes multiple smart contracts to maintain orderbooks and reserves in a decentralized manner. The goal is to get a cohesive view of the orderbooks, reserves, and exchange in a fast, secure manner.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"problem\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#problem\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Problem\")]),e._v(\" \"),s(\"p\",[e._v(\"The current method of blockchain querying would be to have the developer write a custom-solution that queries each individual contract, formats the data, and delivers it to the user. Along with being difficult to create for the developer, this type of system experiences high latency with requests taking minutes.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"solution\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#solution\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Solution\")]),e._v(\" \"),s(\"p\",[e._v(\"The developer can make a Proxima data node that incorporates subgraphs for each of the reserves and orderbooks for their exchange. These subgraphs can be autogenerated to collect events, state, and ensure that this state is truly tied to the blockchain through an authenticated data structure. This enables the developer to have faster queries by several orders of magnitude, while maintaining the security of the blockchain they are querying from.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"outcomes\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#outcomes\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Outcomes\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[e._v(\"Faster queries\")]),e._v(\" \"),s(\"li\",[e._v(\"Lower storage footprint\")]),e._v(\" \"),s(\"li\",[e._v(\"Trustless queries\")]),e._v(\" \"),s(\"li\",[e._v(\"Greater Scalability\")]),e._v(\" \"),s(\"li\",[e._v(\"Easier interface\")]),e._v(\" \"),s(\"li\",[e._v(\"Lower costs\")])]),e._v(\" \"),s(\"h2\",{attrs:{id:\"how-do-we-do-it\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#how-do-we-do-it\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" How do we do it?\")]),e._v(\" \"),s(\"p\",[e._v(\"Proxima provides default mapping of events and stores them within an authenticated data store, giving developers the ability to query this through a graphQL interface. Queries are done through a specialized node that uses an authenticated data store to provide a Merkle-proof for the query. To ensure the security of the data, Proxima leaves an auditable trail for DApp developers to trace the path of their data to its source. We cannot change the authenticated data structure, so security does not have to be re-tried by each new user.\")]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:a(184),alt:\"\"}})]),e._v(\" \"),s(\"h3\",{attrs:{id:\"index-nodes\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#index-nodes\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Index Nodes\")]),e._v(\" \"),s(\"p\",[e._v('The index node is responsible for connecting the queries to the correct \"subgraph\". They will maintain a smart contract index of subgraphs, and eventually be responsible for dealing with payments and subscriptions. The index of subgraphs will be represented as a smart contract on Ethereum through the testnet phase. Eventually the index will be migrated to a higher throughput chain, like the tendermint sidechain on Cosmos.')]),e._v(\" \"),s(\"p\",[s(\"em\",[e._v('Note: the index nodes do not actually store any \"subgraphs\", they simply connect to subgraphs stored by the query nodes.')])]),e._v(\" \"),s(\"h3\",{attrs:{id:\"query-nodes\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#query-nodes\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Query Nodes\")]),e._v(\" \"),s(\"p\",[e._v(\"Query nodes are responsible for storing and providing data for subgraphs. Query nodes can be deployed to our hosting DNS service through a manifest that defines data sources, contracts, and any extra mappings. This manifest is deployed to the IPNS, to enable deployment to the mesh as well as deployment to our own hosting solution.\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"subgraphs\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#subgraphs\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Subgraphs\")]),e._v(\" \"),s(\"p\",[e._v(\"Subgraphs represent a contained data set that can be queried, auditted, and reused within the Proxima network. The easiest analogy for subgraphs, is that they represent tables of data complete with schema, transformations, and queries.\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"subgraph\\n  entities:\\n    - ...\\n  schema:\\n    - ...\\n  mappings:\\n    - ...\\n  datasources:\\n    -  ...\\n\")])])]),s(\"h3\",{attrs:{id:\"entities\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#entities\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Entities\")]),e._v(\" \"),s(\"p\",[e._v('Entities are formulations of objects in Proxima. They can represent Users, Accounts, Items, Orders, etc. The entity will define the values, the \"audits\" associated with the values, and how to index/write the objects to the authenticated database.')]),e._v(\" \"),s(\"h4\",{attrs:{id:\"schema\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#schema\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Schema\")]),e._v(\" \"),s(\"p\",[e._v(\"The schema exists as a part of the entity, it will enable queries, and show the data that is held within the entity. This\\nschema will eventually be able to contain other entities.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"verification\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#verification\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Verification\")]),e._v(\" \"),s(\"p\",[e._v(\"Each entity has a function(s) that will verify the validity of the data they hold. An example of this would be a block\"),s(\"br\"),e._v(\"\\nentity have a verification function that ensures the blockhead hashes to the blockhash.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"audits\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#audits\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Audits\")]),e._v(\" \"),s(\"p\",[e._v(\"An entity will have data from other sources, it is necessary to be able to audit this data. Entities have specific\"),s(\"br\"),e._v('\\nsubroutines that take run queries on subgraphs. These queries are known as \"audits\", and they will ensure the validity of\\nthe data given. An example of such an audit would be a query for a Transaction that checks if the block, associated with the\\nblockHash, exists.')]),e._v(\" \"),s(\"h4\",{attrs:{id:\"example-transaction\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#example-transaction\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Example: Transaction\")]),e._v(\" \"),s(\"p\",[e._v(\"An example entity to use is a transaction, (a UTXO in this case). Look at how the schema defines the data, the\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"schema-2\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#schema-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Schema\")]),e._v(\" \"),s(\"pre\",[s(\"code\",[e._v(\"```\\nTransaction {\\n    transactionHash: Uint256\\n    from: Address\\n    to: Address\\n    value: Uint256\\n    signature: bytes\\n    blockHash: Uint256\\n}\\n```\\n\")])]),e._v(\" \"),s(\"h4\",{attrs:{id:\"verification-2\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#verification-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Verification\")]),e._v(\" \"),s(\"p\",[e._v(\"The verification in this case would be to ensure that the signed Transaction was hashed to the correct Hash. Put simply it would look like:\")]),e._v(\" \"),s(\"div\",{staticClass:\"language-javascript extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"function\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"verification\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[e._v(\"Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" transactionHash\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"{\")]),e._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"return\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"keccak256\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),e._v(\"Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"==\")]),e._v(\" transactionHash\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"}\")]),e._v(\"\\n\")])])]),s(\"h4\",{attrs:{id:\"audits-2\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#audits-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Audits\")]),e._v(\" \"),s(\"p\",[e._v(\"The auditting process would include a query and a validation function. For the transaction it would query the blockHash,\\nthen it would perform the validation function that checks that the transaction is in Transaction Trie of the selected\\nBlock.\")]),e._v(\" \"),s(\"div\",{staticClass:\"language-javascript extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"function\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"AuditTransaction\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[e._v(\"Transaction\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"{\")]),e._v(\"\\n  Block \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"Query\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),e._v(\"Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"return\")]),e._v(\" Block \"),s(\"span\",{pre:!0,attrs:{class:\"token constant\"}},[e._v(\"AND\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"Validate\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),e._v(\"Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" Block\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"}\")]),e._v(\"\\n\")])])]),s(\"h5\",{attrs:{id:\"query\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#query\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Query\")]),e._v(\" \"),s(\"div\",{staticClass:\"language-javascript extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"function\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"Query\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[e._v(\"Transaction\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"{\")]),e._v(\"\\n   Block\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" Proof \"),s(\"span\",{pre:!0,attrs:{class:\"token operator\"}},[e._v(\"=\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"get\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token string\"}},[e._v(\"'subgraph blocks'\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),e._v(\"BlockHash\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\"\\n   \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"if\")]),e._v(\" Proof\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),e._v(\"verify\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\":\")]),e._v(\"\\n     \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"return\")]),e._v(\" Block\\n   \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"return\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"null\")]),e._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"}\")]),e._v(\"\\n\")])])]),s(\"h5\",{attrs:{id:\"validation\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#validation\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Validation\")]),e._v(\" \"),s(\"div\",{staticClass:\"language-javascript extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[s(\"code\",[s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"function\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token function\"}},[e._v(\"Validate\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"(\")]),s(\"span\",{pre:!0,attrs:{class:\"token parameter\"}},[e._v(\"Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\",\")]),e._v(\" Block\")]),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\")\")]),e._v(\" \"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"{\")]),e._v(\"\\n  \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"return\")]),e._v(\" Transaction\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),e._v(\"Hash \"),s(\"span\",{pre:!0,attrs:{class:\"token keyword\"}},[e._v(\"in\")]),e._v(\" Block\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\".\")]),e._v(\"TransactionTrie\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\";\")]),e._v(\"\\n\"),s(\"span\",{pre:!0,attrs:{class:\"token punctuation\"}},[e._v(\"}\")]),e._v(\"\\n\")])])]),s(\"h3\",{attrs:{id:\"datasources\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#datasources\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Datasources\")]),e._v(\" \"),s(\"p\",[e._v(\"Subgraphs can be used by other subgraphs (e.g. Ethereum subgraph being used by DApps), these are defined as datasources.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"subgraphs-2\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#subgraphs-2\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Subgraphs\")]),e._v(\" \"),s(\"p\",[e._v(\"Subgraphs can be used as a datasource for other subgraphs. These subgraphs are referenced and used through the Proxima Index Node. This method makes it easy to define and use subgraphs.\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"  datasource:\\n      type: Subgraph\\n       id: Ethereum-Subgraph\\n      name: Ethereum\\n\")])])]),s(\"h4\",{attrs:{id:\"external-data-sources\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#external-data-sources\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" External data sources\")]),e._v(\" \"),s(\"p\",[e._v(\"External datasources are more difficult to build, and must contain pre-built entities. By doing this it is possible to use the external datasource in the same manner that a subgraph can be used.\")]),e._v(\" \"),s(\"div\",{staticClass:\"language- extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[s(\"code\",[e._v(\"  datasource:\\n      type: External\\n      name: Ethereum\\n      ingestor: ...\\n      entities: ...\\n      mapping:\\n      - handlers\\n      - abi/schema\\n\")])])]),s(\"h2\",{attrs:{id:\"queries\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#queries\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Queries\")]),e._v(\" \"),s(\"p\",[e._v(\"Queries in Proxima, are given responses that are broken into entities. Each entity represents an individual data record that is being requested in the query itself. Since they are designed to be verifiable, they have components for proofs audits.\")]),e._v(\" \"),s(\"p\",[s(\"img\",{attrs:{src:a(185),alt:\"\"}})]),e._v(\" \"),s(\"p\",[e._v(\"Each \"),s(\"em\",[e._v(\"entity\")]),e._v(\" within a query is composed of the following attributes:\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"data\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#data\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Data\")]),e._v(\" \"),s(\"p\",[e._v(\"The data contained within each identity is associated with the schema of the entity itself. This is what the query is looking at.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"proof\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#proof\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Proof\")]),e._v(\" \"),s(\"p\",[e._v(\"This is the \"),s(\"em\",[e._v(\"proof-of-membership\")]),e._v(\" within the Proxima Database. The Proof itself relies on the Merkle root of the database, and is authenticated with the hash of the value.\")]),e._v(\" \"),s(\"h4\",{attrs:{id:\"audits-3\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#audits-3\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Audits\")]),e._v(\" \"),s(\"p\",[e._v(\"The audit provides a \"),s(\"em\",[e._v(\"Proof-of-Correctness\")]),e._v(' for the entity that is being queried, and is sourced by the entity itself. This involves conducting a separate query query of data that is directly tied to the entity. For example, a transaction \"audit\" would return the block whose blockhash is referenced by the transaction, and a proof-of-membership for this block.')]),e._v(\" \"),s(\"h2\",{attrs:{id:\"authenticated-datastore\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#authenticated-datastore\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Authenticated Datastore\")]),e._v(\" \"),s(\"p\",[e._v(\"Proxima uses ProximaDB, a bolt-on component of the powerful Urkel NoSQL database, that implements a Flat-File Merkle Trie (FFMT). We utilize the Flat-File Merkle Trie, like see in Urkel, because of the query speed (>1 ms), the reduced size of the proofs (>1kb), as well as the low storage footprint. FFMTs are especially useful in this implementation because they map from the internal nodes of the trie directly to the location of the data that they are referencing. For more information on this check out the \"),s(\"a\",{attrs:{href:\"https://handshake.org/files/handshake.txt\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"Handshake paper\"),s(\"OutboundLink\")],1),e._v(\".\")]),e._v(\" \"),s(\"p\",[e._v(\"Along with adding features like range queries and load-balancing, Ruffle provides the default authentication and performance seen in the Urkel database. Our data store provides Merkle proofs for data to ensure the authenticity and immutability of all data within it.\")]),e._v(\" \"),s(\"h2\",{attrs:{id:\"audits-4\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#audits-4\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Audits\")]),e._v(\" \"),s(\"p\",[e._v(\"The blocks of a blockchain are immutable, but blocks are only linked to their immediate neighbors, so the history of the blockchain can only be verified by downloading the entire chain. This means that it is only possible to audit data (e.g. transactions, state, and blocks) from a blockchain, by running a full node and synchronizing with every block in the blockchain’s history.\")]),e._v(\" \"),s(\"p\",[e._v(\"Our system maintains the same auditing structure of blockchains, but it stores blocks within an authenticated database, so it is possible to verify membership of blocks without downloading the entire history. This enables fast and efficient audits.\")]),e._v(\" \"),s(\"h3\",{attrs:{id:\"example-audits\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#example-audits\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" Example Audits\")]),e._v(\" \"),s(\"ul\",[s(\"li\",[s(\"em\",[e._v(\"Is this block a part of the Ethereum block?\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"Is this transaction really embedded in this block?\")])]),e._v(\" \"),s(\"li\",[s(\"em\",[e._v(\"Is this state located in the state trie for the current block?\")])])]),e._v(\" \"),s(\"p\",[e._v(\"Audits like these can be called within a query to guarantee that the information provided is correct. Audits can also be chained together in a recursive manner, this is known as an audit trail. As our product progresses, audits can be updated and added to improve the security and rigor of the audit itself.\")]),e._v(\" \"),s(\"p\",[e._v(\"Audits and audit trails would take a lot of time if they are used for every query. Since the database is authenticated, probabilistic audits can be used by developers in instances where there is a high amount of overlap between queries. This lowers the number of audits needed to be completed for highly used sets while maintaining developer security guarantees.\")])])},[],!1,null,null,null);t.default=r.exports}}]);","extractedComments":[]}